\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{color}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{spverbatim}
\usepackage{fancyvrb}
\usepackage{fvextra}
\title{}
\author{}
%
\makeatletter
\setlength{\@fptop}{0pt}
\makeatother
\usepackage[figurename=Fig.]{caption}
%
\begin{document}
\maketitle

\section{Introduction to Bitcoin}\label{sec:introbtc}
Bitcoin address = hash of the public key = receiving address

miners bundle transactions in blocks

blocks are advertised in order to claim a mining reward

blockchain = distributed public ledger

coins are represented only in form of transactions

UTXO unspent transaction output

keep global view of the blockchain consistent

pow + probabilistic distributed consensus protocol

the correct state of the blockchain is obtained by election

to verify transactions miners have to perform a computational task

pow puzzle in sha 256, difficulty exponential on the number of zeros

transaction verification is O(1)

mine a block = hash the txs in the block + varying nonce => solve computational task

reward generating transaction + transaction fees

target value( for the mining difficulty adjustment) changed every 2016 blocks, keeps block verification time around 10 minutes

transactions are stored using a merkle tree

tempering a block is impossible 

natural probabilistic blockchain forks and how they solve by themselves

mining pools

A creates a transaction with a BTC transfer to B, it advertises the transaction to the miners by broadcasting it on the network, miners include the transaction in a block and when they mine it the transaction will belong to the blockchain and will be verified after some time.

partecipants require no authentication (permissionless) to join the network.


itcoin is a cryptocurrency


\subsection{An introductory example to Bitcoin usage}\label{sec:useexample}
A basic usage example, shown in Fig.~\ref{fig:basicexample}, is presented here to get the reader started with Bitcoin.

\begin{figure}[h!]
	\includegraphics[width=.90\textwidth]{pict/basicexample.png}
	\centering
	\caption{Bitcoin introductory use case}
	\label{fig:basicexample}
\end{figure}

Let Alice and Bob be two Bitcoin users with a third-party wallet software. Each wallet is associated with a pair ECDSA keys used to identify users. The private key is used to sign issued transactions; instead, hashing the public key will produce the Bitcoin address on which Bob can receive Bitcoins. 

Suppose that Alice wants to transfer some amount of Bitcoins to Bob. Alice will generate a transaction in which she uses some set of unspent Bitcoins. The generated transaction will then be broadcast to the bitcoin network.

A subset of the nodes, called miners, compete against one another in a parallel transaction confirmation process. Transactions are confirmed once they are included in a block added to the blockchain (\emph{mined} block).

To create a block, miners have to solve an exponentially difficult computational problem and therefore have to employ their computational power for process. The miner that first creates the new block is rewarded with reward, that is included as a \emph{reward generating transaction} in the block, and with the \emph{transaction fees} payed by the users whose transactions have been confirmed.

Once the transaction is included in the blockchain it is confirmed thus the receiver will be able to spend again the transferred coins.
\subsection{Proof-of-work (PoW)}\label{sec:pow}



\paragraph{Why PoW?}\label{sec:whypow}


\subsection{Transaction structure}\label{sec:tx}

Transactions implement transfers and, collected and ordered in the blockchain, represent the entire set of coins available to users and its history. As a case in point, one can determine the balance of a certain wallet just by scanning the transactions on the blockchain~\cite{tschorsch-intro-survey}.

In Fig.~\ref{fig:tx} the reader can find the structure of a transaction, with its main fields.

\begin{figure}[h!]
	\includegraphics[width=.40\textwidth]{pict/txstruct.png}
	\centering
	\caption{Transaction structure}
	\label{fig:tx}
\end{figure}

In particular, the \texttt{lock\_time} field refers to the time or the blockchain height after which the transaction can be included in a block.

Transactions collect a set of \emph{inputs} and \emph{outputs}. Inputs are a collection of unspent coin sets, that are available to the user as previous transaction outputs or \textit{unspent transaction outputs} (UTXO). Outputs, instead, specify the number of coins to be transferred.

Each input and output structure include \emph{scripts}. These are a set of instructions, written in a Forth-like, stack based language that describe the means to access the transferred coins. The script of a standard transaction includes a public key that, when hashed, yields a Bitcoin address, and a private key signature. The most common scripts on the market are \emph{Pay-to-PubKeyHash} (P2PKH) and \emph{Pay-to-ScriptHash} (P2SH).

Broadcast transactions may be deemed invalid by honest miners and thus dropped. That might be the case for transactions that try to spend more than once the same set of coins or use invalid addresses. Nodes that broadcast invalid transactions may incur in bans if their behaviour is considered malicious.

\subsection{Block structure and blockchain}\label{sec:block}
 ciao
 
\begin{figure}[h!]
	\includegraphics[width=.55\textwidth]{pict/blockstruct.png}
	\centering
	\caption{Block structure in the blockchain}
	\label{fig:blockstrcut}
\end{figure}

\subsection{Miners behaviour}\label{sec:miners}
\subsection{Consensus protocol}\label{sec:consensus}

\section{Bitcoin peer-to-peer protocol}\label{sec:netintro}

\begin{figure}[h!]
	\includegraphics[width=.45\textwidth]{pict/blockchain-synch.png}
	\centering
	\caption{blockchcain synch}
	\label{fig:synch}
\end{figure}

\subsection{Connection and peer discovery}\label{sec:peerdisc}
In order to establish a connection two peers need to exchange version messages over an unencrypted TCP channel in an handshake fashion as shown in \emph{Fig.~\ref{fig:btcconn}}. The node that first sends a \texttt{version} message is said to be establishing an \emph{outgoing connection}. The receiving node sets up an \emph{ingoing connection} instead. Once the handshake is completed the connection is fully set up.

\begin{figure}[h]
	\includegraphics[width=.45\textwidth]{pict/BTCconnection.png}
	\centering
	\caption{Peers connection handshake}
	\label{fig:btcconn}
\end{figure}

Each node is able to establish up to 8 outgoing connections and 117 ingoing connections, for a total of 125 connections. In order to keep its connections active, each peer sends a message to each neighbour at least once every thirty minutes. If more than ninety minutes pass without receiving anything from a neighbour, the connection is dropped. Each node always tries to keep eight outgoing connections active, therefore, upon dropping an outgoing connection, a node tries to connect to another address in its peer cache.

Nodes on fresh bootstrap make use of hardcoded \emph{DNS seeds} as their first mean to discover other peers. DNS seed servers are maintained by community members and provide clients with a list of addresses that can be either dynamically gathered through a periodic scan of the network or manually updated by server administrators. As a fallback option the user is able to specify through command line a list of addresses the client can connect to. Were both these two options to fail the client has a hardcoded list of peers it can directly connect to, though this is considered the last resort for bootstrapping peers.

Nodes at startup that were previously on the network shall first lookup peer names in their local address database, implemented as "peer.dat". The database contains the address of each peer the node has come to know during its lifetime in the network.

If the node has disconnected for a time too long, many of the addresses in the database may have become outdated or unreachable. A node that cannot connect to any address in the peer database or has spent up to eleven seconds trying to connect unsuccessfully to at least one of the peers in the database behaves as on fresh bootstrap and resolves to query a DNS first.

The use of a local address database, also called \emph{peer cache}, provides reconnecting peers a fully-decentralized way to join the network and is the first line of defence against \emph{fake bootstrap attacks}; the topic along with other security concerns is discussed in Chapter \ref{netsec}.

Peer discovery after the first connection of a node is carried on through the exchange of \texttt{addr} messages containing the address and port number of other peers in the network. On connection set up the two nodes exchange \texttt{addr} messages, as shown in \emph{Fig.~\ref{fig:addr}}, providing each other with addresses from their local peer database.On top of that, every twenty-four hours each node advertises itself on the network with an \texttt{addr} message containing only its own address.

\begin{figure}[h]
	\includegraphics[width=.45\textwidth]{pict/BTCaddr.png}
	\centering
	\caption{Addresses exchange upon connection}
	\label{fig:addr}
\end{figure}

 \texttt{addr} messages can contain at most one thousand addresses; additionally those containing ten or fewer addresses are relayed. This behaviour contributes to the gossiping of self-advertisement messages even though messages are relayed only to a small subset of neighbours, namely to a couple of peers.

\subsection{Peer database structure}\label{sec:cachestruct}
The local peer database or cache serves the purpose of storing the addresses a node has come to know from \texttt{addr} messages and DNS seeds. The database is constituted of the \texttt{new} and the \texttt{tried} tables.

The \texttt{tried} table contains addresses of peers with whom the node has successfully established a connection in the past. It consists of 64 buckets that can store up to 64 unique addresses. Buckets are selected through a hash on the IP address.

The \texttt{new} table contains the addresses the node has not connected to and is therefore larger: it has 256 buckets of 64 addresses each.

Peer caches have been widely implemented in distributed systems so far as they are a fast and fully-decentralized way to rejoin the network after a disconnection. They allow peer-to-peer systems to overcome major issues at bootstrap time, mainly related to the presence of a single point of failure, i.e. bootstrap servers. Furthermore, they are the most scalable and efficient solution when compared to other decentralized mechanisms such as \textit{address probing}~\cite{decentrbootstrapp2p}.

\section{Bitcoin security concerns}\label{sec:securityintro}
\subsection{Common security threats on cryptocurrecies}
Bitcoin's decentralized, uncontrolled environment is open to a wide range of attacks, many of which can be applied to other cryptocurrencies as well. For this reason the following could be considered attack paradigms, with the same rationale, but different implementation amongst different cryptocurrency systems.

Attacks like \textit{double-spending} aim to exploit system deficiencies: a malicious user tries to spend, with different transactions, the same set of coins two times. Although proof-of-work consensus makes double-spending infeasible, the attack can be still executed through other approaches that manipulate peers, as with network partitions, or were other conditions to be met~\cite{doublespendfastpay}.

Double-spending can be also carried out were an attacker to hold the majority of the computing power, this condition is known as \textit{51\%} or \textit{majority} attack~\cite{51atk}. With the majority of the network's hash rate an attacker would also be able to fork the blockchain to its own advantage and prevent transactions and blocks from being verified; this represents the worst security threat for any cryptocurrency.

Blockchain forks can be exploited to engineer block races as in \textit{selfish mining} attacks, were the malicious user intentionally holds private his mined blocks~\cite{selfishmining},~\cite{leelavimolsilp2018selfish}. If the attacker successfully keeps his private chain longer than the public one it can release his mined blocks, thus claiming the rewards for himself and wasting other miners' computing power.

These are just a few attacks that can be driven onto Bitcoin, as this chapter serves only introductory purposes. In the following sections there is more on network attacks, which are the focus of this thesis. The interested reader can find complete security overviews in the works of Conti et al., Saad et al. and Wang et al.~\cite{completeattacksurvey},~\cite{saad2019attacksurface},~\cite{secpermissionlessblock}.

\subsection{Network security}\label{sec:netsec}
Attacks that exploit vulnerabilities in the design and implementation of Bitcoin protocols and its peer-to-peer network fall under the category of network attacks.

Bitcoin is exposed to all the common threats that affect other peer-to-peer systems; these have been widely studied in the literature as in Touceda et al, 2012~\cite{toucedafakeboot}. The aim of this section is to understand how these attacks apply to Bitcoin and what are its defences.

The attacks reviewed in this chapter mainly focus on topology manipulation, with the exception of the \emph{DDoS} attack.

Often the goal of the attacker is to alter the view of the network of a node, or group of nodes, by sending false network information with the purpose of monopolizing its connections.

Thus victims become isolated and a network partition is created. This condition, often referred to as the \textit{eclipsing} of node, is inherently dangerous for the attacker can alter the node's view of the blockchain, waste its computing power or simply cut off its communications.

More specifically, eclipsed victims are vulnerable to \textit{N-confirmation double spending} and selfish mining attacks; furthermore 51\% attacks are easier to launch~\cite{eclipseatk}. For these reasons network attacks on topology are fundamental enablers for mining and spending attacks~\cite{dotan2020surveychallenges}.\\

In the following sections the reader can find both the attacks performed during the simulations reported in this thesis along with other network level attacks. These were added to better understand the mechanisms exploitable to carry out network attacks on cryptocurrencies.

\begin{figure}[h!]
	\includegraphics[width=.55\textwidth]{pict/network-partition.png}
	\centering
	\caption{Network partition}
	\label{fig:net-part}
\end{figure}


\subsubsection{Sybil attack}\label{sec:sybil}
In a Sybil attack a malicious user controls multiple identities on the network that can be either real machines or dummies, fake replicas of the attacker~\cite{douceur2002sybil}.

Such vector of attacks is applicable to any peer-to-peer system where users can create an arbitrary number of identities on the network for there is no node identification mechanism~\cite{kedziora-sybil-ledgers}. Thus, Bitcoin can suffer from such attacks.

Although the creation of fake identities cannot be exploited to carry out 51\% attacks, since they do not hold any computing power, they can still be used to spread forged information or to withhold blocks.

In the latter scenario, Sybil nodes, upon receiving a new block, send \texttt{inv} messages to their neighbours, but then leave unanswered the following \texttt{getdata} messages, thus delaying the propagation of blocks, as shown in \emph{Fig.~\ref{fig:sybil}}.

\begin{figure}[h!]
	\includegraphics[width=.4\textwidth]{pict/sybil.png}
	\centering
	\caption{Sybil nodes behaviour during the attack}
	\label{fig:sybil}
\end{figure}

If the propagation is delayed long enough, the victim node could start mining the next block - in such scenario a block race can be engineered. Block races occur whenever the blockchain is forked and different subsets of peers work on different branches of the chain.

Since only the longest chain stored among all peers is considered valid, thus all the other branches are dropped, the malicious user can exploit such forks to waste other peers' computing power or to perform double-spending~\cite{zhang-ds-sybil}.

Let Tx 1 and Tx 2 be two different transaction released at the same time by the malicious user,  

In the latter scenario, once the malicious user has successfully created a stale view of the blockchain in the victim, thus a fork, he releases two different transactions, Tx 1 and Tx 2, at the same time. Tx 1 is sent only to the victim node and Tx 2 is kept for its private chain, as shown in Fig. ~\ref{fig:race1}.

In the meanwhile Sybil nodes hamper the growth both of the public and victim's blockchain withholding blocks. As result the attacker can succeed at mining the next block first and then release the private blockchain therefore invalidating the victim's blockchain, as shown in Fig.~\ref{fig:race2}.

\begin{figure}[h!]
	\includegraphics[width=.9\textwidth]{pict/blockrace1.png}
	\centering
	\caption{Block race for double-spending}
	\label{fig:race1}
\end{figure}

\begin{figure}[h!]
	\includegraphics[width=.9\textwidth]{pict/blockrace2.png}
	\centering
	\caption{The attacker releases the longest chain}
	\label{fig:race2}
\end{figure}

Since Bitcoin requires no authentication or authorization process to join the network, there will always be the possibility for adversaries to create Sybils. Nevertheless countermeasures have been studied for different attacks based on Sybil attacks. For instance, setting a transaction block-confirmation timeout, have been suggested by Zhang et al.~\cite{zhang-sybil-mitigations}.

Be that as it may, the implications of Sybil attacks are still a topic open to study. The interested reader can find more in the work of Iqbal et al.~\cite{iqbal-sybil}.

\subsubsection{Eclipse attack}\label{sec:eclipse}
The aim Eclipse attacks is to partition the network so that the attacker may be able to control all the data flow between the two partitions.

In order to do that the malicious node, or a set malicious nodes, floods the victim with a multitude of incoming connections and feed it bogus network information (\texttt{addr} exchanges), i.e. peer addresses controlled by the adversary, that will fill up their peer cache.

Upon restarting, with high probability the victim will form all of its eight outgoing connections with malicious IP addresses, thus finding itself isolated from the network.

Successful Eclipse attacks enable the launch of mining and spending attacks. Namely, eclipsing a subset of peers eliminates their mining power, hence making 51\% attacks easier. Selfish mining attacks can be carried out as well.

The attacker that successfully splits the network can also engineer block races to deliberately waste resources of other miners or attempt at double-spend attacks, as in Fig.~\ref{fig:race1} and Fig.~\ref{fig:race2}, described in Section~\ref{sec:sybil}.

Depending on the victim's policies, the malicious user can launch a \textit{0-confirmation attack}, that is for the case in which the merchant decides to release goods before the transaction is confirmed. As in the case of Sybil based double-spend, the attacker releases two transactions and keeps the victim's view of the blockchain stale, so that it would be dropped later (Fig.~\ref{fig:0confirm}).

Compared to the Sybil-based double-spend, Eclipse-based double-spend attacks of this kind have a greater chance of success, since they control all the victim's traffic and do not have to rely on delaying a block from spreading.

\begin{figure}[h!]
	\includegraphics[width=.7\textwidth]{pict/0confirm-doublespend.png}
	\centering
	\caption{0-confirmation double-spend}
	\label{fig:0confirm}
\end{figure}

Were the victim to adopt a N-blocks confirmation policy for transactions, the attacker can still launch a \textit{N-confirmations double-spend} if it successfully eclipsed a subset of connected peers.

If that is the case, then the victims can be kept on an arbitrarily stale view of the blockchain and then be given one of the two transactions the attacker creates, while giving the other to the rest of the cryptocurrency network. After the eclipsed peers mine $N - 1$ blocks, the transaction is confirmed and the goods are exchanged. Although the obsolete branch of the blockchain known by the victims will be dropped once the attacker releases the up-to-date (and longer) version disseminated in the network (Fig.~\ref{fig:nconfirm} describes the process).  

\begin{figure}[h!]
	\includegraphics[width=.75\textwidth]{pict/nconfirm-doublespend.png}
	\centering
	\caption{N-confirmation double-spend}
	\label{fig:nconfirm}
\end{figure}

In 2015, Heilman et al. widely describe eclipse attacks and suggest many countermeasures to harden the network, a few of which were implemented in Bitcoin Core~\cite{eclipseatk}. As part of the adoption of these countermeasures, the number of buckets in \texttt{new} and \texttt{tried} has been increased, the addresses have become deterministically hashed to a single slot inside a bucket and the heavy bias towards addresses with fresher timestamps when choosing new connections has been removed.


\subsubsection{Fake bootstrapping attack}\label{sec:fakeboot}
Every peer-to-peer system needs some mean to let nodes join the network: in Bitcoin bootstrapping nodes need to rely on the information provided by some other peer in the network.

In a fake bootstrapping attack the peers contacted while a node is still initiating its connections, and hence its knowledge of the network, flood the bootstrapping peer with malicious addresses.

The results in Chapter~\ref{res} show how feeding bogus information to a joining node can seriously influence its view of the network and lead to network partitions and peer eclipsing. This condition would also increase the efficacy of other network-level attacks, such as a DDoS, and the success rate of spending and mining attacks~\cite{eclipseatk}.\\

Prevention is done by ensuring a node can contact a trustworthy peer when joining the network. Peer caches and centralized bootstrap services serve this purpose, allowing joining nodes to make use of old neighbours while having central bootstrap servers as a fallback.

Other solutions have been implemented and tested over time, though their drawbacks usually exceed the benefits. As an example, randomly probing the address space, scouting for peers, decentralizes the bootstrap process and increases the variance of the network knowledge, but may not work if peers are behind NATs or firewalls and increases the latency for joining the network~\cite{decentrbootstrapp2p}~\cite{localityaware}. In 2012,  Touceda et al. discuss fake bootstrapping along with other security threats in their survey~\cite{toucedafakeboot}.

Bitcoin employs many countermeasures, and overcomes other bootstrap issues, with its peer cache implementation mixed with external mechanisms: each node contacts its stored addresses for successive connections and aims to establish multiple outgoing connections, thus it does not rely on a single bootstrap node. On top of that, DNS seeds provide a reliable external bootstrap service and the user is given the ability to manually insert addresses to connect to~\cite{mahmoud_netsec_boot}.


\subsubsection{DDoS attack}\label{sec:ddos}


\section{Results}\label{sec:res}
attack description
methods adopted, metrics and software
results obtained: show them, then discuss them


















\bibliographystyle{plain}
\bibliography{bib.bib}

\end{document}